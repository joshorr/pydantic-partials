{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#install","title":"Install","text":"<pre><code>poetry install pydantic-partials\n</code></pre> <p>or</p> <pre><code>pip install pydantic-partials\n</code></pre>"},{"location":"#introduction","title":"Introduction","text":"<p>You can create from scratch, or convert existing models to be Partials. The main purpose will be to add to exiting models, and hence the default behavior of making all non-default fields partials (configurable).</p> <p>Let's first look at a basic example.</p>"},{"location":"#basic-example","title":"Basic Example","text":"<p>Very basic example of a simple model follows:</p> <pre><code>from pydantic_partials import PartialModel, Missing\n\n\nclass MyModel(PartialModel):\n    some_attr: str\n    another_field: str\n\n# By default, Partial fields without any value will get set to a\n# special `Missing` type. Any field that is set to Missing is\n# excluded from the model_dump/model_dump_json.\nobj = MyModel()\nassert obj.some_attr is Missing\nassert obj.model_dump() == {}\n\n# You can set the real value at any time, and it will behave like expected.\nobj.some_attr = 'hello'\nassert obj.some_attr is 'hello'\nassert obj.model_dump() == {'some_attr': 'hello'}\n\n# You can always manually set a field to `Missing` directly.\nobj.some_attr = Missing\n\n# And now it's removed from the model-dump.\nassert obj.model_dump() == {}\n\n# The json dump is also affected in the same way.\nassert obj.model_dump_json() == '{}'\n\n# Any non-missing fields will be included when dumping/serializing model.\nobj.another_field = 'assigned-value'\n\n# After dumping again, we have `another_field` outputted.\n# The `some_attr` field is not present since it's still `Missing`.\nassert obj.model_dump() == {'another_field': 'assigned-value'}\n</code></pre> <p>By default, all fields without a default value will have the ability to be partial, and can be missing from both validation and serialization. This includes any inherited Pydantic fields (from a superclass).</p>"},{"location":"#inheritable","title":"Inheritable","text":"<p>You can inherit from a model to make a partial-version of the inherited fields:</p> <pre><code>from pydantic_partials import PartialModel, Missing\nfrom pydantic import ValidationError, BaseModel\n\nclass TestModel(BaseModel):\n    name: str\n    value: str\n    some_null_by_default_field: str | None = None\n\ntry:\n    # This should produce an error because\n    # `name` and `value`are required fields.\n    TestModel()\nexcept ValidationError as e:\n    print(f'Pydantic will state `name` + `value` are required: {e}')\nelse:\n    raise Exception('Field `required_decimal` should be required.')\n\n    # We inherit from `TestModel` and add `PartialModel` to the mix.\n\nclass PartialTestModel(PartialModel, TestModel):\n    pass\n\n# `PartialTestModel` can now be allocated without the required fields.\n# Any missing required fields will be marked with the `Missing` value\n# and won't be serialized out.\nobj = PartialTestModel(name='a-name')\n\nassert obj.name == 'a-name'\nassert obj.value is Missing\nassert obj.some_null_by_default_field is None\n\n# The `None` field value is still serialized out,\n# only fields with a `Missing` value assigned are skipped.\nassert obj.model_dump() == {\n    'name': 'a-name', 'some_null_by_default_field': None\n}\n</code></pre> <p>Notice that if a field has a default value, it's used instead of marking it as <code>Missing</code>.</p> <p>Also, the <code>Missing</code> sentinel value is a separate value vs <code>None</code>, allowing one to easily know if a value is truly just missing or is <code>None</code>/<code>Null</code>.</p>"},{"location":"#exclude-fields-from-auto-partials","title":"Exclude Fields From Auto Partials","text":"<p>You can exclude specific fields from the automatic partials via these means:</p> <ul> <li><code>AutoPartialExclude[...]</code></li> <li>This puts a special <code>Annotated</code> item on field to mark it as excluded.</li> <li><code>class PartialRequired(PartialModel, auto_partials_exclude={'id', 'created_at'}):</code></li> <li>This way provides them via class argument <code>auto_partials_exclude</code></li> <li>Or via the standard <code>model_config</code></li> <li><code>model_config = {'auto_partials_exclude': {'id', 'created_at'}}</code></li> <li>A dict, using <code>auto_partials_exclude</code> as the key and a set of field names as the value.</li> </ul> <p>Any of these methods are inheritable. You can override an excluded value by explicitly marking a field as Partial via <code>some_field: Partial[str]</code></p> <p>Here is an example using the <code>AutoPartialExclude</code> method, also showing how it can inherit.</p> <pre><code>from pydantic_partials import PartialModel, AutoPartialExclude, Missing\nfrom pydantic import BaseModel, ValidationError\nfrom datetime import datetime\nimport pytest\n\nclass PartialRequired(PartialModel):\n    id: AutoPartialExclude[str]\n    created_at: AutoPartialExclude[datetime]\n\nclass TestModel(BaseModel):\n    id: str\n    created_at: datetime\n    name: str\n    value: str\n    some_null_by_default_field: str | None = None\n\nclass PartialTestModel(TestModel, PartialRequired):\n    pass\n\n# Will raise validation error for the two fields excluded from auto-partials\nwith pytest.raises(\n    ValidationError,\n    match=r'2 validation errors[\\w\\W]*'\n          r'id[\\w\\W]*Field required[\\w\\W]*'\n          r'created_at[\\w\\W]*Field required'\n):\n    PartialTestModel()\n\n# If we give them values, we get no ValidationError\nobj = PartialTestModel(id='some-value', created_at=datetime.now())\n\n# And fields have the expected values.\nassert obj.id == 'some-value'\nassert obj.name is Missing\n</code></pre>"},{"location":"#auto-partials-configuration","title":"Auto Partials Configuration","text":"<p>You can turn off automatically applying partials to all non-defaulted fields via <code>auto_partials</code> class argument or modeL_config option:</p> <pre><code>from pydantic_partials import PartialModel, PartialConfigDict\n\nclass TestModel1(PartialModel, auto_partials=False):\n    ...\n\nclass TestModel2(PartialModel):\n    model_config = PartialConfigDict(auto_partials=False)\n    ...\n</code></pre> <p>You can disable this automatic function. This means you have complete control of exactly which field  can be partial or not.  You can use either the generic <code>Partial[...]</code> generic or a union with <code>MissingType</code> to mark a field as a partial field.  The generic simple makes the union to MissingType for you.</p> <p>Example of disabling auto_partials:</p> <pre><code>from pydantic_partials import PartialModel, Missing, MissingType, Partial\nfrom decimal import Decimal\nfrom pydantic import ValidationError\n\nclass TestModel(PartialModel, auto_partials=False):\n    # Can use `Partial` generic type\n    partial_int: Partial[int] = Missing\n\n    # Or union with `MissingType`\n    partial_str: str | MissingType\n\n    required_decimal: Decimal\n\ntry:\n    TestModel()\nexcept ValidationError as e:\n    print(f'Pydantic will state `required_decimal` is required: {e}')\nelse:\n    raise Exception('Pydantic should have required `required_decimal`.')\n\nobj = TestModel(required_decimal='1.34')\n\n# You can find out at any time if a field is missing or not:\nassert obj.partial_int is Missing\nassert obj.partial_str is Missing\n\nassert obj.required_decimal == Decimal('1.34')\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#110-2024-10-26","title":"1.1.0 (2024-10-26)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>add way to exclude specific fields from auto partials. (ceeb995)</li> </ul>"},{"location":"changelog/#108-2024-07-17","title":"1.0.8 (2024-07-17)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>ensure our validator only runs when the value type is <code>Missing</code>. (07508c1)</li> </ul>"},{"location":"changelog/#107-2024-07-08","title":"1.0.7 (2024-07-08)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>we want to not change validated object to missing. (9f754f7)</li> <li>when setting values, Pydantic would ask this to serialize them if the type was not exactly what it expected. (90555bd)</li> </ul>"},{"location":"changelog/#106-2024-06-14","title":"1.0.6 (2024-06-14)","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>require python &gt;=3.10, &lt;4 (from &gt;=3.10,&lt;3.11) (2fb0959)</li> </ul>"},{"location":"changelog/#105-2024-06-11","title":"1.0.5 (2024-06-11)","text":""},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>clarifying readme/docs. (d4d85ed)</li> <li>fix extra indent in code example in README.md. (1745485)</li> </ul>"},{"location":"changelog/#104-2024-06-10","title":"1.0.4 (2024-06-10)","text":""},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>added clarification around inheritance and default values. (d09b8a0)</li> </ul>"},{"location":"changelog/#103-2024-06-10","title":"1.0.3 (2024-06-10)","text":""},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li>clarified a point in readme/docs. (6b9fbd0)</li> <li>fix incorrect mkdocs metadata. (fe6779b)</li> </ul>"},{"location":"changelog/#102-2024-06-10","title":"1.0.2 (2024-06-10)","text":""},{"location":"changelog/#documentation_3","title":"Documentation","text":"<ul> <li>readme. (ed0766c)</li> <li>unneeded reference in docs. (6d78d07)</li> </ul>"},{"location":"changelog/#101-2024-06-10","title":"1.0.1 (2024-06-10)","text":""},{"location":"changelog/#documentation_4","title":"Documentation","text":"<ul> <li>generate docs issue. (770cb7c)</li> </ul>"},{"location":"changelog/#100-2024-06-10","title":"1.0.0 (2024-06-10)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>1.0.0 release (0186934)</li> <li>final code adjustments for the initial release of pydantic-partials. (7a680c3)</li> <li>initial commit, want to refactor so committing stuff now. (d0e9aa8)</li> </ul>"},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>version number. (c13313b)</li> </ul>"},{"location":"changelog/#documentation_5","title":"Documentation","text":"<ul> <li>added basic docs to readme. (a0eb544)</li> <li>added/changed doc-comments. (eb1eb7c)</li> </ul>"}]}