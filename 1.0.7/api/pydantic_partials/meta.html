<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pydantic_partials.meta API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pydantic_partials.meta</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import typing
from typing import Any, get_args, get_origin, TypeVar

from pydantic import BaseModel

from pydantic._internal._model_construction import ModelMetaclass
from pydantic_core import PydanticUndefined
from xsentinels import Default
from xsentinels.default import DefaultType

from .config import PartialConfigDict
from .sentinels import Missing, MissingType

from logging import getLogger


# metaclass to make all fields in a model optional, useful for PATCH requests
class PartialMeta(ModelMetaclass):
    &#34;&#34;&#34; Metaclass of `pydantic_partials.partial.PartialModel`, used to support partial fields,
        including the ability ot automatically apply `pydantic_partials.partial.Partial`[...] to fields
        via `pydantic_partials.config.PartialConfigDict.auto_partials` configuration option.
    &#34;&#34;&#34;
    model_partial_fields: typing.ClassVar[set[str]]
    &#34;&#34;&#34; Set of strings representing field names that can be missing from validation/serialization.
        If they are missing, they will return the `Missing` sentinel value and the field will be entirely
        skipped when serializing the model.

        If not missing, they will return their normal value, be included in serializing the model
        and otherwise act normally.

        If any type has their type-hint unioned with `MissingType` it will be a partial field.
        If `auto_add_missing_type` is True (default is True), then all fields on model will automatically
        be unioned with MissingType.
    &#34;&#34;&#34;

    config_dict: PartialConfigDict
    &#34;&#34;&#34; Adding some extra/new config options on-top of the already pre-existing Pydantic ones.
        Seemed like a good place to put them, as it deals with configuration of the class model behavior.
    &#34;&#34;&#34;

    def __new__(
            cls,
            name: str,
            bases: tuple[type],
            namespaces: dict[str, Any],
            *,

            auto_partials: bool | DefaultType = Default,

            # A private/internal detail for generic base subclasses that want to also change the fields,
            # this prevents having to rebuild the class a second time; if this is True then the subclass
            # is responsible for calling rebuild when finished.
            ___PartialMeta__delay_rebuild: bool = False,

            **kwargs
    ):
        &#34;&#34;&#34;

        Args:
            auto_partials: For more details see `pydantic_partials.config.PartialConfigDict.auto_partials`.
                If `Default`: Inherit behavior from parent/model_config; otherwise defaults to `True`.
                If `True` (default): Will automatically make all fields on the model `Partial`.
                If `False`: User needs to mark individual fields as `Partial` where they want.

            **kwargs: Passed along other class arguments to Pydantic and any __init_subclass__ methods.
        &#34;&#34;&#34;
        # Create the class first...
        cls: type[BaseModel] = super().__new__(cls, name, bases, namespaces, **kwargs)  # type: ignore

        # We now have the fields Pydantic found and can now easily add our MissingType&#39;s as needed.
        # Then a model_rebuild is forced to update the class schema to include the MissingType/LazyType annotations,
        # and any needed changes to the field default value.

        if auto_partials is not Default:
            cls.model_config[&#39;auto_partials&#39;] = auto_partials

        need_rebuild = False

        partial_fields = set()
        for k, v in cls.model_fields.items():
            field_type = v.annotation
            if get_origin(field_type) is None:
                if field_type is MissingType:
                    partial_fields.add(k)

            for arg_type in get_args(field_type):
                if arg_type is MissingType:
                    partial_fields.add(k)

        final_partial_auto = cls.model_config.get(&#39;auto_partials&#39;, True)
        if final_partial_auto is not False:
            # I&#39;ll be putting in more options for `final_partial_auto` in the near future,
            # so just check for `is True` for now.
            if final_partial_auto is not True:
                raise ValueError(f&#39;Invalid/Unknown `partial_auto` config value ({final_partial_auto}), use bool value.&#39;)

            for k, v in cls.model_fields.items():
                if k in partial_fields:
                    # The field is already a Partial
                    continue

                if v.default is PydanticUndefined and v.default_factory is None:
                    v.annotation = v.annotation | MissingType
                    partial_fields.add(k)
                    need_rebuild = True

        fields = cls.model_fields
        for k in partial_fields:
            v = fields[k]
            if v.default is PydanticUndefined and v.default_factory is None:
                v.default = Missing
                need_rebuild = True

        cls.model_partial_fields = partial_fields

        if need_rebuild and not ___PartialMeta__delay_rebuild:
            cls.model_rebuild(force=True)
        return cls</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pydantic_partials.meta.PartialMeta"><code class="flex name class">
<span>class <span class="ident">PartialMeta</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Metaclass of <code><a title="pydantic_partials.partial.PartialModel" href="partial.html#pydantic_partials.partial.PartialModel">PartialModel</a></code>, used to support partial fields,
including the ability ot automatically apply <code><a title="pydantic_partials.partial.Partial" href="partial.html#pydantic_partials.partial.Partial">Partial</a></code>[&hellip;] to fields
via <code><a title="pydantic_partials.config.PartialConfigDict.auto_partials" href="config.html#pydantic_partials.config.PartialConfigDict.auto_partials">PartialConfigDict.auto_partials</a></code> configuration option.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PartialMeta(ModelMetaclass):
    &#34;&#34;&#34; Metaclass of `pydantic_partials.partial.PartialModel`, used to support partial fields,
        including the ability ot automatically apply `pydantic_partials.partial.Partial`[...] to fields
        via `pydantic_partials.config.PartialConfigDict.auto_partials` configuration option.
    &#34;&#34;&#34;
    model_partial_fields: typing.ClassVar[set[str]]
    &#34;&#34;&#34; Set of strings representing field names that can be missing from validation/serialization.
        If they are missing, they will return the `Missing` sentinel value and the field will be entirely
        skipped when serializing the model.

        If not missing, they will return their normal value, be included in serializing the model
        and otherwise act normally.

        If any type has their type-hint unioned with `MissingType` it will be a partial field.
        If `auto_add_missing_type` is True (default is True), then all fields on model will automatically
        be unioned with MissingType.
    &#34;&#34;&#34;

    config_dict: PartialConfigDict
    &#34;&#34;&#34; Adding some extra/new config options on-top of the already pre-existing Pydantic ones.
        Seemed like a good place to put them, as it deals with configuration of the class model behavior.
    &#34;&#34;&#34;

    def __new__(
            cls,
            name: str,
            bases: tuple[type],
            namespaces: dict[str, Any],
            *,

            auto_partials: bool | DefaultType = Default,

            # A private/internal detail for generic base subclasses that want to also change the fields,
            # this prevents having to rebuild the class a second time; if this is True then the subclass
            # is responsible for calling rebuild when finished.
            ___PartialMeta__delay_rebuild: bool = False,

            **kwargs
    ):
        &#34;&#34;&#34;

        Args:
            auto_partials: For more details see `pydantic_partials.config.PartialConfigDict.auto_partials`.
                If `Default`: Inherit behavior from parent/model_config; otherwise defaults to `True`.
                If `True` (default): Will automatically make all fields on the model `Partial`.
                If `False`: User needs to mark individual fields as `Partial` where they want.

            **kwargs: Passed along other class arguments to Pydantic and any __init_subclass__ methods.
        &#34;&#34;&#34;
        # Create the class first...
        cls: type[BaseModel] = super().__new__(cls, name, bases, namespaces, **kwargs)  # type: ignore

        # We now have the fields Pydantic found and can now easily add our MissingType&#39;s as needed.
        # Then a model_rebuild is forced to update the class schema to include the MissingType/LazyType annotations,
        # and any needed changes to the field default value.

        if auto_partials is not Default:
            cls.model_config[&#39;auto_partials&#39;] = auto_partials

        need_rebuild = False

        partial_fields = set()
        for k, v in cls.model_fields.items():
            field_type = v.annotation
            if get_origin(field_type) is None:
                if field_type is MissingType:
                    partial_fields.add(k)

            for arg_type in get_args(field_type):
                if arg_type is MissingType:
                    partial_fields.add(k)

        final_partial_auto = cls.model_config.get(&#39;auto_partials&#39;, True)
        if final_partial_auto is not False:
            # I&#39;ll be putting in more options for `final_partial_auto` in the near future,
            # so just check for `is True` for now.
            if final_partial_auto is not True:
                raise ValueError(f&#39;Invalid/Unknown `partial_auto` config value ({final_partial_auto}), use bool value.&#39;)

            for k, v in cls.model_fields.items():
                if k in partial_fields:
                    # The field is already a Partial
                    continue

                if v.default is PydanticUndefined and v.default_factory is None:
                    v.annotation = v.annotation | MissingType
                    partial_fields.add(k)
                    need_rebuild = True

        fields = cls.model_fields
        for k in partial_fields:
            v = fields[k]
            if v.default is PydanticUndefined and v.default_factory is None:
                v.default = Missing
                need_rebuild = True

        cls.model_partial_fields = partial_fields

        if need_rebuild and not ___PartialMeta__delay_rebuild:
            cls.model_rebuild(force=True)
        return cls</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic._internal._model_construction.ModelMetaclass</li>
<li>abc.ABCMeta</li>
<li>builtins.type</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pydantic_partials.meta.PartialMeta.config_dict"><code class="name">var <span class="ident">config_dict</span> : <a title="pydantic_partials.config.PartialConfigDict" href="config.html#pydantic_partials.config.PartialConfigDict">PartialConfigDict</a></code></dt>
<dd>
<div class="desc"><p>Adding some extra/new config options on-top of the already pre-existing Pydantic ones.
Seemed like a good place to put them, as it deals with configuration of the class model behavior.</p></div>
</dd>
<dt id="pydantic_partials.meta.PartialMeta.model_partial_fields"><code class="name">var <span class="ident">model_partial_fields</span> : ClassVar[set[str]]</code></dt>
<dd>
<div class="desc"><p>Set of strings representing field names that can be missing from validation/serialization.
If they are missing, they will return the <code>Missing</code> sentinel value and the field will be entirely
skipped when serializing the model.</p>
<p>If not missing, they will return their normal value, be included in serializing the model
and otherwise act normally.</p>
<p>If any type has their type-hint unioned with <code>MissingType</code> it will be a partial field.
If <code>auto_add_missing_type</code> is True (default is True), then all fields on model will automatically
be unioned with MissingType.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pydantic_partials" href="index.html">pydantic_partials</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pydantic_partials.meta.PartialMeta" href="#pydantic_partials.meta.PartialMeta">PartialMeta</a></code></h4>
<ul class="">
<li><code><a title="pydantic_partials.meta.PartialMeta.config_dict" href="#pydantic_partials.meta.PartialMeta.config_dict">config_dict</a></code></li>
<li><code><a title="pydantic_partials.meta.PartialMeta.model_partial_fields" href="#pydantic_partials.meta.PartialMeta.model_partial_fields">model_partial_fields</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>