<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>pydantic_partials.meta API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pydantic_partials.meta</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pydantic_partials.meta.PartialMeta"><code class="flex name class">
<span>class <span class="ident">PartialMeta</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PartialMeta(ModelMetaclass):
    &#34;&#34;&#34; Metaclass of `pydantic_partials.partial.PartialModel`, used to support partial fields,
        including the ability ot automatically apply `pydantic_partials.partial.Partial`[...] to fields
        via `pydantic_partials.config.PartialConfigDict.auto_partials` configuration option.
    &#34;&#34;&#34;
    model_partial_fields: typing.ClassVar[set[str]]
    &#34;&#34;&#34; Set of strings representing field names that can be missing from validation/serialization.
        If they are missing, they will return the `Missing` sentinel value and the field will be entirely
        skipped when serializing the model.

        If not missing, they will return their normal value, be included in serializing the model
        and otherwise act normally.

        If any type has their type-hint unioned with `MissingType` it will be a partial field.
        If `auto_add_missing_type` is True (default is True), then all fields on model will automatically
        be unioned with MissingType.
    &#34;&#34;&#34;

    config_dict: typing.ClassVar[PartialConfigDict]
    &#34;&#34;&#34; Adding some extra/new config options on-top of the already pre-existing Pydantic ones.
        Seemed like a good place to put them, as it deals with configuration of the class model behavior.
    &#34;&#34;&#34;

    def __new__(
            cls,
            name: str,
            bases: tuple[type],
            namespaces: dict[str, Any],
            *,

            auto_partials: bool | DefaultType = Default,
            auto_partials_exclude: Iterable[str] | DefaultType = Default,

            # A private/internal detail for generic base subclasses that want to also change the fields,
            # this prevents having to rebuild the class a second time; if this is True then the subclass
            # is responsible for calling rebuild when finished.
            ___PartialMeta__delay_rebuild: bool = False,

            **kwargs
    ):
        &#34;&#34;&#34;

        Args:
            auto_partials: For more details see `pydantic_partials.config.PartialConfigDict.auto_partials`.
                If `Default`: Inherit behavior from parent/model_config; otherwise defaults to `False`.
                If `True` (default): Will automatically make all fields on the model as `Partial`.
                If `False`: User needs to mark individual fields as `Missing` or `Partial`.

                Even if this is `False`, we will still go though and set any fields without a default value
                to `Missing` if they have `Missing` or `Partial` in their type-hint/annotation.

            auto_partials_exclude: If `auto_partials` is True, or you inherit from `AutoPartialModel`
                (which simply has `auto_partials` set to `True` by default for you) then this field will be consulted.

                If auto partials is `False` (default) then `auto_partials_exclude` is ignored,
                but we will still keep track of any provided `auto_partials_exclude` in case there is a
                subclass that does enable auto_partials.

                This is a set of strings of field names to exclude from automatic partials.
                If you explicitly mark a field as a Partial, this won&#39;t affect that. THis only effects
                automatically applied partial fields.

                You can also use `pydantic_partials.partial.AutoPartialExclude` to more easily mark fields as excluded.
                For more details see `pydantic_partials.config.PartialConfigDict.auto_partials_exclude`.

            **kwargs: Passed along other class arguments to Pydantic and any __init_subclass__ methods.
        &#34;&#34;&#34;
        # Create the class first...
        cls: &#39;Type[PartialModel]&#39; = super().__new__(cls, name, bases, namespaces, **kwargs)  # type: ignore

        model_config: PartialConfigDict = cls.model_config  # type: ignore

        # We now have the fields Pydantic found and can now easily add our MissingType&#39;s as needed.
        # Then a model_rebuild is forced to update the class schema to include the MissingType/LazyType annotations,
        # and any needed changes to the field default value.

        if auto_partials is not Default:
            model_config[&#39;auto_partials&#39;] = bool(auto_partials)

        if auto_partials_exclude:
            model_config[&#39;auto_partials_exclude&#39;] = set(auto_partials_exclude)  # type: ignore

        # Inherit any pre-existing `auto_partials_exclude` items.
        # For now if someone wants to override this, they can simply manually do this on subclass:
        #     `field_name: Partial[...]`
        # I might consider a simple way to inform us to not inherit excludes, but for now keeping things simple.
        final_auto_exclude = model_config.get(&#39;auto_partials_exclude&#39;, set())
        for c in cls.__mro__:  # type: ignore
            parent_config: PartialConfigDict | None = getattr(c, &#39;model_config&#39;, None)
            if not parent_config:
                continue

            final_auto_exclude.update(parent_config.get(&#39;auto_partials_exclude&#39;, set()))

        need_rebuild = False

        partial_fields = set()
        for k, v in cls.model_fields.items():  # type: ignore
            field_type = v.annotation
            origin = get_origin(field_type)
            if origin is None:
                if field_type is MissingType:
                    partial_fields.add(k)

            # TODO: Check that `field_type` is a union?
            for arg_type in get_args(field_type):
                if arg_type is MissingType:
                    partial_fields.add(k)

            for mdv in v.metadata:
                # If we find the marker AND we are not already marked as a partial_field,
                # add field to auto-exclude list.
                if mdv is AutoPartialExcludeMarker and k not in partial_fields:
                    final_auto_exclude.add(k)

        if final_auto_exclude:
            model_config[&#39;auto_partials_exclude&#39;] = final_auto_exclude

        # Default to `False` for auto-partials.
        final_partial_auto = model_config.get(&#39;auto_partials&#39;, False)
        if final_partial_auto is not False:
            # I&#39;ll be putting in more options for `final_partial_auto` in the near future,
            # so just check for `is True` for now.
            if final_partial_auto is not True:
                raise ValueError(f&#39;Invalid/Unknown `partial_auto` config value ({final_partial_auto}), use bool value.&#39;)

            for k, v in cls.model_fields.items():  # type: ignore
                if k in partial_fields:
                    # The field is already a Partial
                    continue

                if k in final_auto_exclude:
                    # The field is excluded.
                    continue

                if v.default is PydanticUndefined and v.default_factory is None:
                    v.annotation = v.annotation | MissingType
                    partial_fields.add(k)
                    need_rebuild = True

        fields: dict[str, FieldInfo] = cls.model_fields  # type: ignore
        for k in partial_fields:
            v = fields[k]
            if v.default is PydanticUndefined and v.default_factory is None:
                v.default = Missing
                need_rebuild = True

            if existing_exclude_if := v.exclude_if:
                # Execute ours and their exclude if, if either returns `True`, then exclude it.
                def combine_ignore_missing_check_with_existing_exclude_if(x, existing_exclude_if=existing_exclude_if):
                    return _exclude_if_missing(x) or existing_exclude_if(x)
                v.exclude_if = combine_ignore_missing_check_with_existing_exclude_if
            else:
                # Otherwise, we only have our method so directly set it.
                v.exclude_if = _exclude_if_missing
                need_rebuild = True

        cls.model_partial_fields = partial_fields

        if need_rebuild and not ___PartialMeta__delay_rebuild:
            cls.model_rebuild(force=True)  # type: ignore
        return cls</code></pre>
</details>
<div class="desc"><p>Metaclass of <code><a title="pydantic_partials.partial.PartialModel" href="partial.html#pydantic_partials.partial.PartialModel">PartialModel</a></code>, used to support partial fields,
including the ability ot automatically apply <code><a title="pydantic_partials.partial.Partial" href="partial.html#pydantic_partials.partial.Partial">Partial</a></code>[&hellip;] to fields
via <code><a title="pydantic_partials.config.PartialConfigDict.auto_partials" href="config.html#pydantic_partials.config.PartialConfigDict.auto_partials">PartialConfigDict.auto_partials</a></code> configuration option.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic._internal._model_construction.ModelMetaclass</li>
<li>abc.ABCMeta</li>
<li>builtins.type</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pydantic_partials.meta.PartialMeta.config_dict"><code class="name">var <span class="ident">config_dict</span> : ClassVar[<a title="pydantic_partials.config.PartialConfigDict" href="config.html#pydantic_partials.config.PartialConfigDict">PartialConfigDict</a>]</code></dt>
<dd>
<div class="desc"><p>Adding some extra/new config options on-top of the already pre-existing Pydantic ones.
Seemed like a good place to put them, as it deals with configuration of the class model behavior.</p></div>
</dd>
<dt id="pydantic_partials.meta.PartialMeta.model_partial_fields"><code class="name">var <span class="ident">model_partial_fields</span> : ClassVar[set[str]]</code></dt>
<dd>
<div class="desc"><p>Set of strings representing field names that can be missing from validation/serialization.
If they are missing, they will return the <code>Missing</code> sentinel value and the field will be entirely
skipped when serializing the model.</p>
<p>If not missing, they will return their normal value, be included in serializing the model
and otherwise act normally.</p>
<p>If any type has their type-hint unioned with <code>MissingType</code> it will be a partial field.
If <code>auto_add_missing_type</code> is True (default is True), then all fields on model will automatically
be unioned with MissingType.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pydantic_partials" href="index.html">pydantic_partials</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pydantic_partials.meta.PartialMeta" href="#pydantic_partials.meta.PartialMeta">PartialMeta</a></code></h4>
<ul class="">
<li><code><a title="pydantic_partials.meta.PartialMeta.config_dict" href="#pydantic_partials.meta.PartialMeta.config_dict">config_dict</a></code></li>
<li><code><a title="pydantic_partials.meta.PartialMeta.model_partial_fields" href="#pydantic_partials.meta.PartialMeta.model_partial_fields">model_partial_fields</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
