{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#important-upgrade-from-v1x-to-2x-notes","title":"Important Upgrade from v1.x to 2.x Notes","text":"<p>I decided to make the default behavior of <code>PartialModel</code> not be automatic anymore.</p> <p>I made a new class named <code>AutoPartialModel</code> that works exactly the same as the old v1.x <code>PartialModel</code> previously did.</p> <p>To upgrade, simply replace <code>PartialModel</code> with <code>AutoPartialModel</code>, and things will work exactly as they did before. The <code>auto_partials</code> configuration option is still present and if present will still override the base-class setting.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#install","title":"Install","text":"<pre><code>poetry install pydantic-partials\n</code></pre> <p>or</p> <pre><code>pip install pydantic-partials\n</code></pre>"},{"location":"#introduction","title":"Introduction","text":"<p>You can create from scratch, or convert existing models to be Partials. The main purpose will be to add to exiting models, and hence the default behavior of making all non-default fields partials (configurable).</p>"},{"location":"#two-partial-base-class-options","title":"Two Partial Base Class Options","text":"<p>There are two options to inherit from:</p> <ul> <li><code>PartialModel</code></li> <li>With this one, you must explicitly set which fields are partial</li> <li>To get correct static type checking, you also can also set a partial field's default value to <code>Missing</code>.</li> <li><code>AutoPartialModel</code></li> <li>This automatically applies partial behavior to every attribute that does not already have a default value.</li> </ul> <p>Let's first look at a basic example.</p>"},{"location":"#explicitly-defined-partials-basic-example","title":"Explicitly Defined Partials - Basic Example","text":"<p>Very basic example of a simple model with explicitly defined partial fields, follows:</p> <pre><code>from pydantic_partials import PartialModel, Missing, Partial, MissingType\nfrom pydantic import ValidationError\n\nclass MyModel(PartialModel):\n    some_field: str\n    partial_field: Partial[str] = Missing\n\n    # Alternate Syntax:\n    alternate_syntax_partial_field: str | MissingType = Missing\n\n\n# By default, `Partial` fields without any value will get set to a\n# special `Missing` type. Any field that is set to Missing is\n# excluded from the model_dump/model_dump_json.\nobj = MyModel(some_field='a-value')\nassert obj.partial_field is Missing\nassert obj.model_dump() == {'some_field': 'a-value'}\n\n# You can set the real value at any time, and it will behave like expected.\nobj.partial_field = 'hello'\nassert obj.partial_field == 'hello'\nassert obj.model_dump() == {'some_field': 'a-value', 'partial_field': 'hello'}\n\n# You can always manually set a field to `Missing` directly.\nobj.partial_field = Missing\n\n# And now it's removed from the model-dump.\nassert obj.model_dump() == {'some_field': 'a-value'}\n\n# The json dump is also affected in the same way.\nassert obj.model_dump_json() == '{\"some_field\":\"a-value\"}'\n\ntry:\n    # This should produce an error because\n    # `some_field` is a required field.\n    MyModel()\nexcept ValidationError as e:\n    print(f'Pydantic will state `some_field` is required: {e}')\nelse:\n    raise Exception('Pydantic should have required `some_field`.')\n</code></pre>"},{"location":"#automatically-defined-partials-basic-example","title":"Automatically Defined Partials - Basic Example","text":"<p>Very basic example of a simple model with automatically defined partial fields, follows:</p> <pre><code>from pydantic_partials import AutoPartialModel, Missing\n\nclass MyModel(AutoPartialModel):\n    some_attr: str\n    another_field: str\n\n# By default, automatic defined partial fields without any value will get set to a\n# special `Missing` type. Any field that is set to Missing is\n# excluded from the model_dump/model_dump_json.\nobj = MyModel()\nassert obj.some_attr is Missing\nassert obj.model_dump() == {}\n\n# You can set the real value at any time, and it will behave like expected.\nobj.some_attr = 'hello'\nassert obj.some_attr is 'hello'\nassert obj.model_dump() == {'some_attr': 'hello'}\n\n# You can always manually set a field to `Missing` directly.\nobj.some_attr = Missing\n\n# And now it's removed from the model-dump.\nassert obj.model_dump() == {}\n\n# The json dump is also affected in the same way.\nassert obj.model_dump_json() == '{}'\n\n# Any non-missing fields will be included when dumping/serializing model.\nobj.another_field = 'assigned-value'\n\n# After dumping again, we have `another_field` outputted.\n# The `some_attr` field is not present since it's still `Missing`.\nassert obj.model_dump() == {'another_field': 'assigned-value'}\n</code></pre> <p>By default, all fields without a default value will have the ability to be partial, and can be missing from both validation and serialization. This includes any inherited Pydantic fields (from a superclass).</p>"},{"location":"#more-details","title":"More Details","text":""},{"location":"#inheritable","title":"Inheritable","text":"<p>With <code>AutoPartialModel</code>, you can inherit from a model to make an automatic partial-version of the inherited fields:</p> <pre><code>from pydantic_partials import AutoPartialModel, Missing\nfrom pydantic import ValidationError, BaseModel\n\nclass TestModel(BaseModel):\n    name: str\n    value: str\n    some_null_by_default_field: str | None = None\n\ntry:\n    # This should produce an error because\n    # `name` and `value`are required fields.\n    TestModel()\nexcept ValidationError as e:\n    print(f'Pydantic will state `name` + `value` are required: {e}')\nelse:\n    raise Exception('Pydantic should have required `required_decimal`.')\n\n    # We inherit from `TestModel` and add `PartialModel` to the mix.\n\nclass PartialTestModel(AutoPartialModel, TestModel):\n    pass\n\n# `PartialTestModel` can now be allocated without the required fields.\n# Any missing required fields will be marked with the `Missing` value\n# and won't be serialized out.\nobj = PartialTestModel(name='a-name')\n\nassert obj.name == 'a-name'\nassert obj.value is Missing\nassert obj.some_null_by_default_field is None\n\n# The `None` field value is still serialized out,\n# only fields with a `Missing` value assigned are skipped.\nassert obj.model_dump() == {\n    'name': 'a-name', 'some_null_by_default_field': None\n}\n</code></pre> <p>Notice that if a field has a default value, it's used instead of marking it as <code>Missing</code>.</p> <p>Also, the <code>Missing</code> sentinel value is a separate value vs <code>None</code>, allowing one to easily know if a value is truly just missing or is <code>None</code>/<code>Null</code>.</p>"},{"location":"#exclude-fields-from-automatic-partials-autopartialmodel","title":"Exclude Fields from Automatic Partials (AutoPartialModel)","text":"<p>You can exclude specific fields from the automatic partials via these means:</p> <ul> <li><code>AutoPartialExclude[...]</code></li> <li>This puts a special <code>Annotated</code> item on field to mark it as excluded.</li> <li><code>class PartialRequired(PartialModel, auto_partials_exclude={'id', 'created_at'}):</code></li> <li>This way provides them via class argument <code>auto_partials_exclude</code></li> <li>Or via the standard <code>model_config</code></li> <li><code>model_config = {'auto_partials_exclude': {'id', 'created_at'}}</code></li> <li>A dict, using <code>auto_partials_exclude</code> as the key and a set of field names as the value.</li> </ul> <p>Any of these methods are inheritable. You can override an excluded value by explicitly marking a field as Partial via <code>some_field: Partial[str]</code></p> <p>Here is an example using the <code>AutoPartialExclude</code> method, also showing how it can inherit.</p> <pre><code>from pydantic_partials import AutoPartialModel, AutoPartialExclude, Missing\nfrom pydantic import BaseModel, ValidationError\nfrom datetime import datetime\nimport pytest\n\nclass PartialRequired(AutoPartialModel):\n    id: AutoPartialExclude[str]\n    created_at: AutoPartialExclude[datetime]\n\nclass TestModel(BaseModel):\n    id: str\n    created_at: datetime\n    name: str\n    value: str\n    some_null_by_default_field: str | None = None\n\nclass PartialTestModel(TestModel, PartialRequired):\n    pass\n\n# Will raise validation error for the two fields excluded from auto-partials\nwith pytest.raises(\n    ValidationError,\n    match=r'2 validation errors[\\w\\W]*'\n          r'id[\\w\\W]*Field required[\\w\\W]*'\n          r'created_at[\\w\\W]*Field required'\n):\n    # This should raise a 'ValidationError'\n    PartialTestModel()  # type: ignore\n\n# If we give them values, we get no ValidationError\nobj = PartialTestModel(id='some-value', created_at=datetime.now())  # type: ignore\n\n# And fields have the expected values.\nassert obj.id == 'some-value'\nassert obj.name is Missing\n</code></pre>"},{"location":"#auto-partials-configuration","title":"Auto Partials Configuration","text":"<p>Normally you would simply inherit from either <code>PartialModel</code> or <code>AutoPartialModel</code>, depending on the desired behavior you want.</p> <p>But you can also configure the auto-partials aspect via class paramters or the <code>model_config</code> attribute:</p> <pre><code>from pydantic_partials import PartialModel, PartialConfigDict, AutoPartialModel\n\n# `PartialModel` uses `auto_partials` as `False` by default, but we can override that if you want via class argument:\nclass TestModel1(PartialModel, auto_partials=True):\n    ...\n\n# Or via `model_config`\n# (PartialConfigDict inherits from Pydantic's `ConfigDict`,\n#  so you have all of Pydantic's options still available).\nclass TestModel2(AutoPartialModel):\n    model_config = PartialConfigDict(auto_partials=False)\n    ...\n</code></pre> <p>You can disable this automatic function. This means you have complete control of exactly which field  can be partial or not.  You can use either the generic <code>Partial[...]</code> generic or a union with <code>MissingType</code> to mark a field as a partial field.  The generic simple makes the union to MissingType for you.</p> <pre><code>from pydantic_partials import PartialModel, Missing, MissingType, Partial\nfrom decimal import Decimal\nfrom pydantic import ValidationError\n\nclass TestModel(PartialModel):\n    # Can use `Partial` generic type\n    partial_int: Partial[int] = Missing\n\n    # Or union with `MissingType`\n    partial_str: str | MissingType\n\n    required_decimal: Decimal\n\ntry:\n    TestModel()\nexcept ValidationError as e:\n    print(f'Pydantic will state `required_decimal` is required: {e}')\nelse:\n    raise Exception('Pydantic should have required `required_decimal`.')\n\nobj = TestModel(required_decimal='1.34')\n\n# You can find out at any time if a field is missing or not:\nassert obj.partial_int is Missing\nassert obj.partial_str is Missing\n\nassert obj.required_decimal == Decimal('1.34')\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#201-2025-01-31","title":"2.0.1 (2025-01-31)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>update/generate new docs after fixing/tweaking them. (b307401)</li> </ul>"},{"location":"changelog/#200-2025-01-30","title":"2.0.0 (2025-01-30)","text":""},{"location":"changelog/#breaking-changes","title":"\u26a0 BREAKING CHANGES","text":"<ul> <li>Support mypy + make <code>PartialModel</code> not auto-define partial fields, use <code>AutoPartialModel</code> instead if you want the old behavior.</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Support mypy + make <code>PartialModel</code> not auto-define partial fields, use <code>AutoPartialModel</code> instead if you want the old behavior. (b6b669e)</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>adjust docs supported python version and make upgrade title more clear. (2c39761)</li> </ul>"},{"location":"changelog/#110-2024-10-26","title":"1.1.0 (2024-10-26)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>add way to exclude specific fields from auto partials. (ceeb995)</li> </ul>"},{"location":"changelog/#108-2024-07-17","title":"1.0.8 (2024-07-17)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>ensure our validator only runs when the value type is <code>Missing</code>. (07508c1)</li> </ul>"},{"location":"changelog/#107-2024-07-08","title":"1.0.7 (2024-07-08)","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>we want to not change validated object to missing. (9f754f7)</li> <li>when setting values, Pydantic would ask this to serialize them if the type was not exactly what it expected. (90555bd)</li> </ul>"},{"location":"changelog/#106-2024-06-14","title":"1.0.6 (2024-06-14)","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>require python &gt;=3.10, &lt;4 (from &gt;=3.10,&lt;3.11) (2fb0959)</li> </ul>"},{"location":"changelog/#105-2024-06-11","title":"1.0.5 (2024-06-11)","text":""},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>clarifying readme/docs. (d4d85ed)</li> <li>fix extra indent in code example in README.md. (1745485)</li> </ul>"},{"location":"changelog/#104-2024-06-10","title":"1.0.4 (2024-06-10)","text":""},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li>added clarification around inheritance and default values. (d09b8a0)</li> </ul>"},{"location":"changelog/#103-2024-06-10","title":"1.0.3 (2024-06-10)","text":""},{"location":"changelog/#documentation_3","title":"Documentation","text":"<ul> <li>clarified a point in readme/docs. (6b9fbd0)</li> <li>fix incorrect mkdocs metadata. (fe6779b)</li> </ul>"},{"location":"changelog/#102-2024-06-10","title":"1.0.2 (2024-06-10)","text":""},{"location":"changelog/#documentation_4","title":"Documentation","text":"<ul> <li>readme. (ed0766c)</li> <li>unneeded reference in docs. (6d78d07)</li> </ul>"},{"location":"changelog/#101-2024-06-10","title":"1.0.1 (2024-06-10)","text":""},{"location":"changelog/#documentation_5","title":"Documentation","text":"<ul> <li>generate docs issue. (770cb7c)</li> </ul>"},{"location":"changelog/#100-2024-06-10","title":"1.0.0 (2024-06-10)","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>1.0.0 release (0186934)</li> <li>final code adjustments for the initial release of pydantic-partials. (7a680c3)</li> <li>initial commit, want to refactor so committing stuff now. (d0e9aa8)</li> </ul>"},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>version number. (c13313b)</li> </ul>"},{"location":"changelog/#documentation_6","title":"Documentation","text":"<ul> <li>added basic docs to readme. (a0eb544)</li> <li>added/changed doc-comments. (eb1eb7c)</li> </ul>"}]}